package main

import (
	"context"
	"fmt"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"go.mongodb.org/mongo-driver/mongo/readpref"
	"google.golang.org/grpc"
	"log"
	"net"
	pb "shopping_list.microservice/generated/shopping_list.microservice/proto_generated"
	props "shopping_list.microservice/main/util"
)

type ShoppingList struct {
	name     string
	products []Product
}

// ProductType is an enum. In go enum does not exist
type ProductType int64

const (
	Meat ProductType = iota // con la parola chiave iota si definiscono i tipi dell'enum
	Fish
	Fruit
	Vegetable
	Drink
	Other
)

// Unit is an enum
type Unit int64

const (
	Bottle Unit = iota
	Packet
	Kg
	Grams
)

type Product struct {
	itemId      int64 // an int with type ProductId.Two Products with the same name can have different ProductIds
	productName string
	prodType    ProductType
	unit        Unit
	quantity    int32
	bought      bool // true if it is checked on the list
	// expireDate string // Todo: usare una data
}

type OpType int64

const (
	Insert OpType = iota
	Remove
	Modify
)

type DBOperation struct {
	opType     OpType
	elemsToAdd []Product
}

//func (p Product) ToString() string {
//    return fmt.Sprintf("Product(%d, %s, %d, %s, %s)\n", p.id, p.name, p.prodType, p.expire_date, p.expire_date)
//}
//
//func (s ShoppingList) ToString() string{
//    return fmt.Sprintf("ShoppingList: %s\n%v", s.name, s.products) // %v stampa la struct senza i nomi. %+v stampa anche i nomi
//}

// this struct implements ShoppingListServer interface
type serverShoppingList struct {
	pb.UnimplementedShoppingListServer // generated by protoc. It is an Anonymous Field, with the same name as the type (pb.UnimplementedGreeterServer).
}

// TODO: Remember to add error as second return value

// AddProductToList is the function to be called remotely. It is a method of the server struct (class)
func (s *serverShoppingList) AddProductToList(ctx context.Context, product *pb.Product) (*pb.Response, error) {
	log.Printf("Received: %+v", product)
	// TODO: aggiungi prodotto a un database (es. mongodb)
	operation := new(DBOperation)
	operation.opType = Insert
	// TODO: necessario unmarshalling per estrarre dati da product
	//operation.elemsToAdd = append(operation.elemsToAdd, product)
	queryDB(*operation)
	return &pb.Response{Msg: "Ok - Product added"}, nil
}

func (s *serverShoppingList) RemoveProductFromList(ctx context.Context, productId *pb.ProductId) (*pb.Product, error) {
	log.Printf("Removing product: %d", productId.ProductId)
	// TODO: rimuovi prodotto dal database (es. mongodb)

	removedProduct := removeProduct()
	prod := pb.Product{
		ItemId: &pb.ProductId{
			ProductId: removedProduct.itemId,
		},
		ProductName: removedProduct.productName,
		Type:        pb.ProductType(removedProduct.prodType),
		Unit:        pb.Unit(removedProduct.unit),
		Quantity:    removedProduct.quantity, // we show the removed quantity
		AddedToCart: false,
	}
	return &prod, nil
}

func (s *serverShoppingList) UpdateProductInList(ctx context.Context, product *pb.Product) (*pb.Response, error) {
	// TODO: aggiorna prodotto nel database (es. mongodb)
	return &pb.Response{Msg: "ok - product updated"}, nil
}

// TODO: questa funzione dovrebbe checkare un prodotto messo nel carrello oppure comprare tutti i prodotti
//  nel primo caso: i prodotti dovrebbero essere aggiunti e rimossi molto pi√π spesso nel carrello, ma uno alla volta (Questa funzinoe fa questo)
//  nel secondo caso: i prodotti checkati dovrebbero essere inviati direttamente in dispensa, tutti insieme. (questo dovrebbe esser fatto da productStorage, questo microservizio fa da client)

// AddProductToCart sets the product as added to cart
func (s *serverShoppingList) AddProductToCart(ctx context.Context, productId *pb.ProductId) (*pb.Response, error) {
	return &pb.Response{Msg: "ok - product added to cart"}, nil
}

// RemoveProductFromCart sets the product as not added to cart yet
func (s *serverShoppingList) RemoveProductFromCart(ctx context.Context, productId *pb.ProductId) (*pb.Response, error) {
	return &pb.Response{Msg: "ok - product removed from cart"}, nil
}

func (s *serverShoppingList) GetList(ctx context.Context, listId *pb.ListId) (*pb.ProductList, error) {
	return &pb.ProductList{
		Id:       &pb.ListId{ListId: 1},
		Name:     "Product List",
		Products: nil,
	}, nil
}

func (s *serverShoppingList) BuyAllProductsInCart(ctx context.Context, listId *pb.ListId) (*pb.Response, error) {
	return &pb.Response{Msg: "ok - all product bought and sent to pantry"}, nil
}

func removeProduct() Product {
	return Product{}
}

/* Function to query the MongoDB database */
func queryDB(operation DBOperation) {
	// connect mongo database
	client, err := mongo.Connect(context.TODO(), options.Client().ApplyURI("mongodb://root:example@mongo:27017"))
	if err != nil {
		panic(err)
	}
	// ping the database to check if there is a connected database
	if err := client.Ping(context.TODO(), readpref.Primary()); err != nil {
		panic(err)
	}
	// TODO: create database appdb if not existing
	// add products collection to database
	prodCollection := client.Database("appdb").Collection("products")

	if operation.opType == Insert {
		var products []interface{}
		// add the elements to an interface of bson elements
		for i := 0; i < len(operation.elemsToAdd); i++ {
			prod := operation.elemsToAdd[i]
			prodType := prod.prodType
			prodUnit := prod.unit
			prodId := prod.itemId
			prodQuantity := prod.quantity
			prodName := prod.productName
			prodIsBought := prod.bought

			currentProd := []interface{}{bson.D{
				{"prodType", prodType},
				{"prodUnit", prodUnit},
				{"prodId", prodId},
				{"prodQuantity", prodQuantity},
				{"prodName", prodName},
				{"bought", prodIsBought},
			}}
			products = append(products, currentProd)
		}
		// insert the bson object slice using InsertMany()
		results, err := prodCollection.InsertMany(context.TODO(), products)
		// check for errors in the insertion
		if err != nil {
			panic(err)
		}
		// display the ids of the newly inserted objects
		fmt.Println(results.InsertedIDs)
	} else if operation.opType == Remove {
		// remove specified elements from the collection
	}
}

// Run in the server/ directory
// go run .\server.go
// PREREQUISITE in this folder!!: protoc --go_out generated --go-grpc_out generated shopping_list.proto
func main() {
	// Retrieve the properties from the file
	properties, _ := props.GetProperties()
	fmt.Printf("Properties %+v\n", properties)

	// Listen for incoming requests
	lis, err := net.Listen("tcp", fmt.Sprintf(":%d", properties.ShoppingListPort))
	if err != nil {
		log.Fatalf("failed to listen: %v", err)
	}

	// Create server
	s := grpc.NewServer()
	pb.RegisterShoppingListServer(s, &serverShoppingList{}) // this is a pointer to a newly created server struct that implements ShoppingListServer
	log.Printf("server listening at %v", lis.Addr())

	// this is like C's
	// int err;
	// if ((err = s.serve(lis) != ERROR_CONSTANT) {}
	if err := s.Serve(lis); err != nil {
		log.Fatalf("failed to serve: %v", err)
	}
}

// TODO: ELIMINA!
func useless() {
	//prod := Product{
	//	id:          1,
	//	name:        "Prosciutto",
	//	prodType:    Meat,
	//	expire_date: "2022/12/31",
	//	expired:     false,
	//}
	//
	//product_list := make([]Product, 10)
	//
	//product_list[0] = prod
	//
	//shoppingList := ShoppingList{
	//	name:     "lista1",
	//	products: product_list,
	//}
	//
	//fmt.Printf("This is a shopping list.\n%+v\n", shoppingList)
	val, _ := props.GetProperties()
	fmt.Printf("Properties %+v\n", val)
}
