package main

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/go-redis/redis/v8"
	"github.com/gocql/gocql"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"io/ioutil"
	"log"
	"net"
	"net/http"
	pb "recipes.microservice/generated"
	props "recipes.microservice/main/util"
	"strconv"
	"time"
)

var rediCli *redis.Client
var ctx context.Context

//var session *gocql.Session

type GeneralInfo struct {
	Id                int          `json:"id,omitempty"`
	Title             string       `json:"title,omitempty"`
	MissedIngredients []Ingredient `json:"missedIngredients,omitempty"`
	UsedIngredients   []Ingredient `json:"usedIngredients,omitempty"`
	Likes             int          `json:"likes,omitempty"`
}

type UrlInfo struct { // contains the url of the recipe
	Url string `json:"spoonacularSourceUrl,omitempty"`
}

type Ingredient struct {
	Name string `json:"name,omitempty"`
}

// this struct implements RecipesServer interface
type serverRecipes struct {
	pb.UnimplementedRecipesServer // generated by protoc. It is an Anonymous Field, with the same name as the type (pb.UnimplementedGreeterServer).
}

func (s *serverRecipes) GetRecipesFromIngredients(ctx context.Context, ingredients *pb.IngredientsList) (*pb.RecipeList, error) {
	// TODO
	recipes := make([]*pb.Recipe, 0)

	x := &pb.RecipeList{
		Recipes: recipes,
	}
	return x, nil
}

func (s *serverRecipes) GetRecipesFromPantry(_ context.Context, _ *pb.RecipesRequest) (*pb.RecipeList, error) {
	// Call GetPantry of StorageService to retrieve available products
	conn, err := grpc.Dial("ProductStorageService:8002", grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		log.Fatalln("Error connecting to ProductStorageService", err)
		return nil, err
	}
	client := pb.NewProductStorageClient(conn)
	pantry, err := client.GetPantry(context.Background(), &pb.PantryMessage{})
	log.Printf("pantry: %v", pantry)

	// Get only available and not expired products from pantry
	products := pantry.GetProducts()
	available := make([]*pb.Item, 0)
	ts := time.Now()
	for i := range products {
		item := products[i]
		isAvailable := item.Quantity != 0
		notExpired := int(item.Expiration.Seconds) >= ts.Second()
		if isAvailable && notExpired {
			available = append(available, item)
		}
	}
	// Append all available items to single string
	str := appendToSingleString(available)
	// Query Spoonacular API using the str
	recipeGeneral := getFromAPI("https://api.spoonacular.com/recipes/findByIngredients" +
		"?apiKey=053dc1707c6d4a9aa63b246bb543cc1d" +
		"&ingredients=" + str + "")
	generalList := unmarshalToListGeneralInfo(recipeGeneral)
	urlList := unmarshalToUrlInfo(generalList)
	recipes := convertToProtobuf(generalList, urlList)
	log.Printf("recipes list: %v", recipes)

	// Return recipes list
	x := &pb.RecipeList{
		Recipes: recipes,
	}
	return x, nil
}

func convertToProtobuf(generals []GeneralInfo, urls []UrlInfo) []*pb.Recipe {
	recipes := make([]*pb.Recipe, 0)
	missedRes := make([]*pb.Ingredient, 0)
	usedRes := make([]*pb.Ingredient, 0)
	for i := range generals {
		generalInfo := generals[i]
		url := urls[i].Url
		title := generalInfo.Title
		missed := generalInfo.MissedIngredients
		id := generalInfo.Id
		for missedIndex := range missed {
			m := missed[missedIndex]
			missedRes = append(missedRes, &pb.Ingredient{Name: m.Name})
		}
		used := generalInfo.UsedIngredients
		for usedIndex := range used {
			u := used[usedIndex]
			usedRes = append(usedRes, &pb.Ingredient{Name: u.Name})
		}
		recipe := &pb.Recipe{
			Id:                strconv.Itoa(id),
			Title:             title,
			Url:               url,
			UsedIngredients:   usedRes,
			MissedIngredients: missedRes,
		}
		recipes = append(recipes, recipe)
	}
	return recipes
}

func getFromAPI(apiURL string) []byte {
	// try to get element from cache, else ask remote API
	cached := getEntryFromRedis(apiURL)
	if cached == "" {
		// ask remote API
		response, err := http.Get(apiURL)
		if err != nil {
			fmt.Print(err.Error())
		}
		responseData, err := ioutil.ReadAll(response.Body)
		if err != nil {
			log.Fatal(err)
		}
		// add element in cache for future requests
		setEntryInRedis(apiURL, responseData)
		return responseData
	}
	return []byte(cached)
}

func unmarshalToListGeneralInfo(responseData []byte) []GeneralInfo {
	var response []GeneralInfo
	err := json.Unmarshal(responseData, &response)
	if err != nil {
		log.Fatal(err)
	}
	return response
}

func unmarshalToUrlInfo(recipeList []GeneralInfo) []UrlInfo {
	resList := make([]UrlInfo, 0)
	for i := range recipeList {
		var response UrlInfo
		id := recipeList[i].Id
		responseData := getFromAPI("https://api.spoonacular.com/recipes/" + strconv.Itoa(id) + "/information" +
			"?apiKey=053dc1707c6d4a9aa63b246bb543cc1d")
		err := json.Unmarshal(responseData, &response)
		if err != nil {
			log.Fatal(err)
		}
		resList = append(resList, response)
	}
	return resList
}

func appendToSingleString(availableItems []*pb.Item) string {
	var finalStr = ""
	for i := range availableItems {
		item := availableItems[i]
		finalStr = finalStr + item.ItemName + ","
	}
	return finalStr
}

func connectToRedis() (context.Context, *redis.Client) {
	ctx := context.Background()

	rdb := redis.NewClient(&redis.Options{
		Addr:     "redis-cache:6379",
		Password: "", // no password set
		DB:       0,  // use default DB
	})

	pong, err := rdb.Ping(ctx).Result()
	fmt.Println(pong, err)
	return ctx, rdb
}

func setEntryInRedis(key string, value []byte) {
	// we can call set with a `Key` and a `Value`.
	expiration := time.Duration.Hours(48)
	err := rediCli.Set(ctx, key, value, time.Duration(expiration)).Err()
	// if there has been an error setting the value
	// handle the error
	if err != nil {
		fmt.Println(err)
	}
}

func getEntryFromRedis(key string) string {
	val, err := rediCli.Get(ctx, key).Result()
	if err != nil {
		fmt.Println(err)
		return ""
	}
	fmt.Println(val)
	return val
}

func connectToCassandra() *gocql.Session {
	cluster := gocql.NewCluster("192.168.119.2")
	cluster.ProtoVersion = 4
	cluster.Authenticator = gocql.PasswordAuthenticator{
		Username: "cassandra",
		Password: "cassandra",
	}
	session, err := cluster.CreateSession()
	if err != nil {
		fmt.Println(err)
		panic(err)
	}
	fmt.Println("cassandra init done.")
	defer session.Close()
	return session

	// todo EXAMPLE CODE
	//// create keyspaces
	//err = session.Query("CREATE KEYSPACE IF NOT EXISTS sleep_centre WITH REPLICATION = {'class' : 'SimpleStrategy','replication_factor' : 1};").Exec()
	//if err != nil {
	//	log.Println(err)
	//	return
	//}
	//fmt.Println("created keyspace.")

	//// create table
	//err = session.Query("CREATE TABLE IF NOT EXISTS sleep_centre.sleep_study (name text, study_date date, sleep_time_hours float, PRIMARY KEY (name, study_date));").Exec()
	//if err != nil {
	//	log.Println(err)
	//	return
	//}
	//fmt.Println("created table.")
	//
	//// insert some practice data
	//err = session.Query("INSERT INTO sleep_centre.sleep_study (name, study_date, sleep_time_hours) VALUES ('James', '2018-01-07', 8.2);").Exec()
	//err = session.Query("INSERT INTO sleep_centre.sleep_study (name, study_date, sleep_time_hours) VALUES ('James', '2018-01-08', 6.4);").Exec()
	//err = session.Query("INSERT INTO sleep_centre.sleep_study (name, study_date, sleep_time_hours) VALUES ('James', '2018-01-09', 7.5);").Exec()
	//err = session.Query("INSERT INTO sleep_centre.sleep_study (name, study_date, sleep_time_hours) VALUES ('Bob', '2018-01-07', 6.6);").Exec()
	//err = session.Query("INSERT INTO sleep_centre.sleep_study (name, study_date, sleep_time_hours) VALUES ('Bob', '2018-01-08', 6.3);").Exec()
	//err = session.Query("INSERT INTO sleep_centre.sleep_study (name, study_date, sleep_time_hours) VALUES ('Bob', '2018-01-09', 6.7);").Exec()
	//err = session.Query("INSERT INTO sleep_centre.sleep_study (name, study_date, sleep_time_hours) VALUES ('Emily', '2018-01-07', 7.2);").Exec()
	//err = session.Query("INSERT INTO sleep_centre.sleep_study (name, study_date, sleep_time_hours) VALUES ('Emily', '2018-01-09', 7.5);").Exec()
	//if err != nil {
	//	log.Println(err)
	//	return
	//}
	//fmt.Println("inserted practice data.")
	//
	//// Return average sleep time for James
	//var sleepTimeHours float32
	//
	//sleepTimeOutput := session.Query("SELECT avg(sleep_time_hours) FROM sleep_centre.sleep_study WHERE name = 'James';").Iter()
	//sleepTimeOutput.Scan(&sleepTimeHours)
	//fmt.Println("Average sleep time for James was: ", sleepTimeHours, "h")
	//
	//// return average sleep time for group
	//sleepTimeOutput = session.Query("SELECT avg(sleep_time_hours) FROM sleep_centre.sleep_study;").Iter()
	//sleepTimeOutput.Scan(&sleepTimeHours)
	//fmt.Println("Average sleep time for the group was: ", sleepTimeHours, "h")
}

//protoc --proto_path ../../proto --go_out generated --go-grpc_out generated ../../proto/*.proto
func main() {
	// Retrieve the properties from the file
	properties, _ := props.GetProperties()
	fmt.Printf("Properties %+v\n", properties)
	var err error

	ctx, rediCli = connectToRedis()
	//FIXME session = connectToCassandra()

	// Listen for incoming requests
	lis, err := net.Listen("tcp", fmt.Sprintf(":%d", properties.RecipesPort))
	if err != nil {
		log.Fatalf("failed to listen: %v", err)
	}

	// Create server
	s := grpc.NewServer()
	pb.RegisterRecipesServer(s, &serverRecipes{}) // this is a pointer to a newly created server struct that implements ShoppingListServer
	log.Printf("server listening at %v", lis.Addr())

	// this is like C's
	// int err;
	// if ((err = s.serve(lis) != ERROR_CONSTANT) {}
	if err := s.Serve(lis); err != nil {
		log.Fatalf("failed to serve: %v", err)
	}
	fmt.Println("here we give hints. What do you need more?")
}
